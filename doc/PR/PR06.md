# PR#6: 単語カウンターの実装

## 📋 概要
形態素解析結果とメッセージ全文の集計を行う単語カウンターサービスを実装しました。形態素解析で抽出された単語の出現回数を集計する機能と、メッセージ全文を1単語として扱い完全一致・部分一致をカウントする機能を提供します。部分一致検索では1メッセージ内に対象文字列が複数回出現する場合、非重複カウントで集計します。計算量削減のため、文字数による絞り込み機能（最小・最大文字数の指定）を実装しました。17の単体テストにより100%のコードカバレッジを達成しています。

## 🎯 目的
- 形態素解析結果の単語出現回数の集計
- メッセージ全文の完全一致・部分一致のカウント
- 各単語・メッセージの出現情報（日時、ユーザー、メッセージ）の記録
- 基本形による単語の統合（「走る」「走った」→「走る」でカウント）
- 仕様書（SPEC.md section 5.3）通りの処理フローの実現

## 🔧 変更内容

### 1. app/services/__init__.py
- `WordCounter`、`WordCount`、`MessageCount`のエクスポートを追加
- `__all__`の更新

### 2. app/services/word_counter.py
#### WordCountデータクラス
- 単語のカウント情報を表現する構造化データ型
- **フィールド**
  - `word` (str): 単語（表層形）
  - `base_form` (str): 基本形
  - `count` (int): 出現回数
  - `part_of_speech` (str): 品詞
  - `appearances` (list[Message]): 出現したメッセージのリスト
- `@dataclass`デコレータによる簡潔な実装

#### MessageCountデータクラス
- メッセージのカウント情報を表現する構造化データ型
- **フィールド**
  - `message` (str): メッセージ本文
  - `exact_count` (int): 完全一致カウント
  - `partial_count` (int): 部分一致カウント
  - `total_count` (int): 合計カウント
  - `exact_appearances` (list[Message]): 完全一致したメッセージのリスト
  - `partial_appearances` (list[Message]): 部分一致したメッセージのリスト
- `@dataclass`デコレータによる簡潔な実装

#### WordCounterクラス
**主要メソッド**

1. **`count_morphological_words(messages: list[Message], words_by_message: list[list[Word]], min_word_length: int = 1, max_word_length: int | None = None) -> list[WordCount]`**
   - 形態素解析結果の集計を行うメソッド
   - **処理フロー**
     1. 基本形をキーとして単語をグループ化（`defaultdict`を使用）
     2. 各メッセージの単語リストを走査
     3. 文字数フィルタリング（min_word_length ≤ 単語長 ≤ max_word_length）
     4. 単語の基本形で集約（「走る」「走った」→「走る」）
     5. 出現回数をカウント
     6. 出現したメッセージ情報を記録
     7. `WordCount`オブジェクトのリストを返却
   - **引数**
     - `messages`: メッセージのリスト
     - `words_by_message`: メッセージごとの単語リスト（messagesと同じ順序）
     - `min_word_length`: 集計対象の最小文字数（デフォルト: 1）
     - `max_word_length`: 集計対象の最大文字数（デフォルト: None=無制限）
   - **返り値**: 単語カウント結果のリスト
   - **設計上の工夫**: `Message`はハッシュ可能でないため、辞書のキーに使えない。そのため`dict[Message, list[Word]]`ではなく`list[list[Word]]`を引数として受け取り、インデックスで対応づける

2. **`count_full_messages(messages: list[Message], min_message_length: int = 1, max_message_length: int | None = None) -> list[MessageCount]`**
   - メッセージ全文の集計を行うメソッド
   - **処理フロー**
     1. メッセージ本文をキーとして集計（`defaultdict`を使用）
     2. 完全一致のカウント：同一メッセージの出現回数
     3. 文字数フィルタリング（min_message_length ≤ メッセージ長 ≤ max_message_length）
     4. 部分一致のカウント：`_find_partial_matches()`で検索
     5. 出現情報を記録（完全一致・部分一致を分けて保存）
     6. 合計カウント（完全一致 + 部分一致）を計算
     7. `MessageCount`オブジェクトのリストを返却
   - **引数**
     - `messages`: メッセージのリスト
     - `min_message_length`: 部分一致検索対象の最小文字数（デフォルト: 1）
     - `max_message_length`: 部分一致検索対象の最大文字数（デフォルト: None=無制限）
   - **返り値**: メッセージカウント結果のリスト
   - **注意**: 文字数フィルタは部分一致検索の対象を絞り込むためのもの。完全一致カウントは全メッセージが対象

3. **`_find_partial_matches(target: str, messages: list[Message]) -> list[Message]`**
   - 部分一致検索を行う内部メソッド
   - **処理詳細**
     - 対象メッセージを部分文字列として含む他のメッセージを検索
     - 完全一致は除外（`message.content == target`の場合はスキップ）
     - 1メッセージ内に複数回出現する場合、複数回カウント（`_count_occurrences()`を使用）
     - 例: 「それな」を含む「それな；；」「それなwww」をカウント
     - 例: 「＾＾」は「それな＾＾＾＾」内に2回出現
   - **引数**
     - `target`: 検索対象のメッセージ本文
     - `messages`: 全メッセージのリスト
   - **返り値**: 部分一致したメッセージのリスト（複数回出現する場合は重複して含まれる）

4. **`_count_occurrences(substring: str, text: str) -> int`**
   - 文字列内の部分文字列の出現回数を非重複でカウントする内部メソッド
   - **処理詳細**
     - `str.find()`で部分文字列を検索
     - 見つかった位置から`len(substring)`分進んで次の検索開始位置を設定
     - これにより非重複（見つけた部分文字列を消費してから次を検索）でカウント
   - **例**
     - `"＾＾＾＾"`内の`"＾＾"` → 2回（位置0-1と2-3）
     - `"AAA"`内の`"AA"` → 1回（位置0-1のみ、残りは"A"）
     - `"AAAAAA"`内の`"AA"` → 3回（位置0-1、2-3、4-5）
   - **引数**
     - `substring`: 検索する部分文字列
     - `text`: 検索対象のテキスト
   - **返り値**: 出現回数

### 3. tests/unit/test_word_counter.py
#### TestWordCountクラス（1テスト）
- `test_create_instance`: `WordCount`データクラスのインスタンス化テスト

#### TestMessageCountクラス（1テスト）
- `test_create_instance`: `MessageCount`データクラスのインスタンス化テスト

#### TestWordCounterクラス（13テスト）

**形態素解析結果のカウントテスト**
1. `test_count_morphological_words`: 標準的な単語カウント
2. `test_count_morphological_words_with_same_base_form`: 基本形による統合
3. `test_count_morphological_words_empty`: 空のデータセット
4. `test_count_morphological_words_with_length_filter`: 文字数フィルタリング（NEW）

**メッセージ全文のカウントテスト**
5. `test_count_full_messages_exact_match`: 完全一致カウント
6. `test_count_full_messages_partial_match`: 部分一致カウント
7. `test_count_full_messages_nested_partial_match`: 入れ子状の部分一致
8. `test_count_full_messages_empty`: 空のメッセージリスト
9. `test_count_full_messages_with_length_filter`: メッセージ文字数フィルタリング（NEW）

**部分一致検索テスト**
10. `test_find_partial_matches`: 部分一致の検索
11. `test_find_partial_matches_no_match`: 部分一致が見つからない場合
12. `test_find_partial_matches_multiple_occurrences`: 1メッセージ内に複数回出現するケース

**複数回出現カウントテスト**
13. `test_count_occurrences`: 非重複カウントの動作確認

**出現情報の記録テスト**
14. `test_word_appearances_recorded`: 単語の出現情報
15. `test_message_appearances_recorded`: メッセージの出現情報（完全一致・部分一致）

## ✅ テスト結果

全てのテスト項目をクリアしました：

- [x] **単体テスト**: 17テスト全てパス
  ```bash
  $ pytest tests/unit/test_word_counter.py -v
  collected 17 items
  tests/unit/test_word_counter.py::TestWordCount::test_create_instance PASSED                                              [  5%]
  tests/unit/test_word_counter.py::TestMessageCount::test_create_instance PASSED                                           [ 11%]
  tests/unit/test_word_counter.py::TestWordCounter::test_count_morphological_words PASSED                                  [ 17%]
  tests/unit/test_word_counter.py::TestWordCounter::test_count_morphological_words_with_same_base_form PASSED              [ 23%]
  tests/unit/test_word_counter.py::TestWordCounter::test_count_morphological_words_empty PASSED                            [ 29%]
  tests/unit/test_word_counter.py::TestWordCounter::test_count_morphological_words_with_length_filter PASSED               [ 35%]
  tests/unit/test_word_counter.py::TestWordCounter::test_count_full_messages_exact_match PASSED                            [ 41%]
  tests/unit/test_word_counter.py::TestWordCounter::test_count_full_messages_partial_match PASSED                          [ 47%]
  tests/unit/test_word_counter.py::TestWordCounter::test_count_full_messages_nested_partial_match PASSED                   [ 52%]
  tests/unit/test_word_counter.py::TestWordCounter::test_count_full_messages_empty PASSED                                  [ 58%]
  tests/unit/test_word_counter.py::TestWordCounter::test_count_full_messages_with_length_filter PASSED                     [ 64%]
  tests/unit/test_word_counter.py::TestWordCounter::test_find_partial_matches PASSED                                       [ 70%]
  tests/unit/test_word_counter.py::TestWordCounter::test_find_partial_matches_no_match PASSED                              [ 76%]
  tests/unit/test_word_counter.py::TestWordCounter::test_find_partial_matches_multiple_occurrences PASSED                  [ 82%]
  tests/unit/test_word_counter.py::TestWordCounter::test_count_occurrences PASSED                                          [ 88%]
  tests/unit/test_word_counter.py::TestWordCounter::test_word_appearances_recorded PASSED                                  [ 94%]
  tests/unit/test_word_counter.py::TestWordCounter::test_message_appearances_recorded PASSED                               [100%]

  ====================================================== 17 passed in 0.42s ======================================================
  ```

- [x] **コードカバレッジ**: 100%
  ```bash
  $ pytest tests/unit/test_word_counter.py --cov=app.services.word_counter --cov-report=term-missing
  Name                           Stmts   Miss  Cover   Missing
  ------------------------------------------------------------
  app/services/word_counter.py      79      0   100%
  ------------------------------------------------------------
  TOTAL                             79      0   100%

  ====================================================== 17 passed in 0.60s ======================================================
  ```

- [x] **コード品質チェック**: 全てパス
  - **Black**: フォーマット済み（2ファイル）
  - **isort**: インポート順序修正済み（2ファイル）
  - **flake8**: エラーなし
  - **mypy**: `Success: no issues found in 2 source files`

## 🔍 実装の詳細

### 基本形による単語の統合
形態素解析では、活用形を持つ単語（動詞、形容詞）は基本形で統一します：
- 例: 「走る」「走った」「走って」→ すべて「走る」としてカウント
- 実装: `word.base_form`をキーとして`defaultdict`でグループ化

```python
# 基本形をキーとして単語をグループ化
word_dict: dict[str, dict[str, Any]] = defaultdict(
    lambda: {
        "surface": "",      # 表層形（最初に出現した形）
        "base_form": "",    # 基本形
        "count": 0,         # 出現回数
        "part_of_speech": "",  # 品詞
        "appearances": [],  # 出現メッセージ
    }
)
```

### メッセージ全文の部分一致カウント
メッセージ全文を1単語として扱い、以下の2種類のカウントを行います：
- **完全一致**: 同一メッセージの出現回数
- **部分一致**: そのメッセージを部分文字列として含む他のメッセージ（複数回出現もカウント）

例1：
```
メッセージ: 「それな」
- 完全一致: 「それな」が1回出現
- 部分一致: 「それな；；」「それなwww」の2回
- 合計: 3回
```

例2（複数回出現）：
```
メッセージ: 「＾＾」
- 完全一致: 「＾＾」が5回出現
- 部分一致: 「それな＾＾＾＾」（2回含まれる）、「＾＾www＾＾」（2回含まれる）の計4回
- 合計: 9回
```

### 非重複カウントアルゴリズム
1メッセージ内に対象文字列が複数回出現する場合、非重複カウント（見つけた部分文字列を消費してから次を検索）を使用します：

```python
def _count_occurrences(self, substring: str, text: str) -> int:
    count = 0
    start = 0
    while True:
        pos = text.find(substring, start)
        if pos == -1:
            break
        count += 1
        start = pos + len(substring)  # 見つけた部分文字列の長さ分進む
    return count
```

例：
- `"＾＾＾＾"`内の`"＾＾"` → 2回（位置0-1と2-3）
- `"AAA"`内の`"AA"` → 1回（位置0-1のみ、残りは"A"）
- `"testtest"`内の`"test"` → 2回（位置0-3と4-7）

### Messageをハッシュ可能にしない設計判断
`@dataclass`の`Message`は`frozen=True`にするとハッシュ可能になり、辞書のキーとして使えます。しかし、以下の理由で採用しませんでした：
- PR#4で既に`Message`が実装済みで、変更の影響範囲が大きい
- `frozen=True`にすると変更不可になり、将来的な拡張性が低下
- インデックスベースのアプローチでも十分にシンプル

実装:
```python
def count_morphological_words(
    self, messages: list[Message], words_by_message: list[list[Word]]
) -> list[WordCount]:
    for i, words in enumerate(words_by_message):
        message = messages[i]  # インデックスで対応づけ
        for word in words:
            # カウント処理
```

### defaultdictの活用
Pythonの`defaultdict`を使用することで、キーが存在しない場合のデフォルト値を自動設定し、コードを簡潔に保ちました：

```python
from collections import defaultdict

# 辞書に初期値を自動設定
word_dict: dict[str, dict[str, Any]] = defaultdict(
    lambda: {"count": 0, "appearances": []}
)

# キーが存在しなくても安全にアクセス可能
word_dict[key]["count"] += 1  # 初回は0から1に
```

## 📝 学習事項

### データクラスのハッシュ可能性
Pythonの`@dataclass`は、以下の場合にハッシュ可能になります：
- `frozen=True`が設定されている
- すべてのフィールドがハッシュ可能な型

ハッシュ不可能なデータクラスは辞書のキーやセットの要素として使用できません。

### パフォーマンスの考慮
- **基本形でのグループ化**: O(n)の時間計算量で効率的
- **部分一致検索**: O(n×m)（n=メッセージ数、m=平均メッセージ長）
  - **文字数フィルタリングによる最適化**: 最小・最大文字数を指定して検索対象を絞り込むことで計算量を削減
  - 例: `min_message_length=2, max_message_length=10`で1文字や長文メッセージを除外
  - 将来的に大量データで遅い場合は、トライ木やサフィックス配列などの高速化手法を検討

### 文字数フィルタリング機能（追加機能）
計算量削減のため、文字数による絞り込み機能を実装しました：

**形態素解析結果のフィルタリング**:
```python
# 2文字以上10文字以下の単語のみカウント
word_counts = counter.count_morphological_words(
    messages, words_by_message, 
    min_word_length=2, 
    max_word_length=10
)
```

**メッセージ全文のフィルタリング**:
```python
# 2文字以上10文字以下のメッセージのみ部分一致検索を実行
message_counts = counter.count_full_messages(
    messages, 
    min_message_length=2, 
    max_message_length=10
)
```

**利点**:
- 1文字の単語や記号のみのメッセージを除外
- 非常に長いメッセージの部分一致検索をスキップ
- 計算量をO(n×m)からO(n'×m)に削減（n' < n）
- 実用上、2-10文字程度のメッセージが流行語の対象となることが多い

## 🔗 依存関係
- **使用元**: 次のPR#7（統合解析サービス）で使用予定
- **依存先**: 
  - PR#4（LINEトーク履歴パーサー）の`Message`
  - PR#5（形態素解析サービス）の`Word`

## 🚀 次のステップ
PR#7で`TalkAnalyzer`サービスを実装する際、本サービスを以下のように活用します：
```python
from app.services import WordCounter, MorphologicalAnalyzer, LineMessageParser

# パース
parser = LineMessageParser()
messages = parser.parse(file)

# 形態素解析
analyzer = MorphologicalAnalyzer()
words_by_message = [analyzer.analyze(msg.content) for msg in messages]

# カウント
counter = WordCounter()
word_counts = counter.count_morphological_words(messages, words_by_message)
message_counts = counter.count_full_messages(messages)
```

## ✨ 実装のポイント

### 設計上の工夫
1. **データクラスの活用**: 型安全な構造化データで出現情報を保持
2. **基本形による統合**: 活用形の異なる同一単語を1つにまとめる
3. **完全一致と部分一致の分離**: 2種類のカウントを独立して管理
4. **インデックスベースの設計**: ハッシュ不可能な`Message`への対応
5. **文字数フィルタリング**: 計算量削減のための柔軟な絞り込み機能

### テストカバレッジ100%の達成
- 正常系: 標準的なカウント処理
- 境界値: 空のデータセット
- 特殊ケース: 入れ子状の部分一致、基本形の統合、文字数フィルタリング
- 出現情報: 記録内容の正確性
- 複数回出現: 非重複カウントの動作確認

### 拡張性
- 新しい集計方法の追加が容易（新しいメソッドを追加）
- 将来的な最適化（部分一致検索の高速化など）に対応可能
- 統計情報の追加（平均出現回数、標準偏差など）が容易

## 📚 参考資料
- [Python collections.defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict)
- [Python dataclasses](https://docs.python.org/3/library/dataclasses.html)
- [型ヒント（typing）](https://docs.python.org/3/library/typing.html)
